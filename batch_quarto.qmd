---
title: "SANGER ANALYSIS REPORT"
subtitle: "Complete analysis report on CRSIPR edited reads after Sanger sequencing, using ICE and R statistical analysis."
date: now
format: 
  html: 
    title-block-banner: true
    title-block-style: default
    toc: true
    toc-depth: 2
    toc-title: "Contents"
    toc-location: left
    theme:
      light: minty
      dark: darkly
    embed-resources: true
    df-print: kable
    code-links: 
    - text: CRISPR Analysis Repo
      icon: github
      href: https://github.com/Akschya/CRISPR_Analysis 
params:
  sample_name: "default_sample" 
editor: visual
---

```{r}
#| label: Environment variables setup
#| include: false

### Env variable setup ###
# Set environment variables dynamically in the R chunk
output_dir <- Sys.getenv("OUTPUT_DIR")
input_ab1 <- Sys.getenv("INPUT_AB1")
sample_name <- params$sample_name 
batch_input_file <- Sys.getenv("BATCH_INPUT_FILE")
output_path_plots <- file.path(output_dir, "Outputs", sample_name, "Plots")
output_path_results <- file.path(output_dir, "Outputs", sample_name, "Results") 
```

```{css classDummyTable, echo=FALSE}
.dummyTable .table thead {
    visibility: collapse;
}
.dummyTable .table tbody {
    visibility: collapse;
}
.dummyTable .table {
    border-collapse: inherit;
    padding-bottom: none;
}
.dummyTable .table.table.table-sm.table-striped.small {
    margin: auto;
}
```

```{r}
#| label: R environment setup
#| include: false

#### R ENV SETUP ####
options(warn = -1)  # Suppress warnings
options(repos = c(
  binary = "https://packagemanager.rstudio.com/all/__linux__/focal/latest",
  source = "https://packagemanager.rstudio.com/all/latest",
  CRAN = "https://cloud.r-project.org",
  djnavarro = "https://djnavarro.r-universe.dev",
  Bioconductor = "https://bioconductor.org/packages/release/bioc"
))

# Load the yaml package to read YAML files
if (!require(yaml)) {
  suppressWarnings(install.packages("yaml"))
  library(yaml)
}
if (!requireNamespace("BiocManager", quietly = TRUE))
    suppressWarnings(install.packages("BiocManager"))
    library(BiocManager)

install_packages <- function(file = "packages.yml") {
  # Read the YAML file
  packages <- yaml::read_yaml(file)
  
  # Check if the 'packages' key exists
  if (!is.list(packages) || is.null(packages$packages)) {
    stop("Invalid structure in YAML file. Expected a top-level 'packages' key.")
  }
  
  # Extract sections (base and bioconductor) if they exist
  base_pkgs <- packages$packages$base
  bioconductor_pkgs <- packages$packages$bioconductor
  dev_pkgs <- packages$packages$devtools
  
  # Install base packages
  if (!is.null(base_pkgs) && length(base_pkgs) > 0) {
    for (pkg in base_pkgs) {
      if (!requireNamespace(pkg, quietly = TRUE)) {
        suppressWarnings(install.packages(pkg))
      }
    }
  }
  
  # Install Bioconductor packages
  if (!is.null(bioconductor_pkgs) && length(bioconductor_pkgs) > 0) {
    bioc_pkgs <- BiocManager::available()
    for (pkg in bioconductor_pkgs) {
      if (pkg %in% bioc_pkgs && !requireNamespace(pkg, quietly = TRUE)) {
        suppressWarnings(BiocManager::install(pkg, ask = FALSE))
      }
    }
  }
 # Install devtools packages
if (!is.null(dev_pkgs) && length(dev_pkgs) > 0) {
    for (pkg in dev_pkgs) {
      if (!requireNamespace(pkg, quietly = TRUE)) {
        suppressWarnings(devtools::install_github(pkg))
      }
    }
  }
}

install_packages()
```

```{r}
#| label: Load libraries
#| include: false

# Load necessary libraries
suppressPackageStartupMessages(library(sangerseqR))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(Biostrings))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(reactable))
suppressPackageStartupMessages(library(writexl))
suppressPackageStartupMessages(library(ggmsa))
suppressPackageStartupMessages(library(jsonlite))
suppressPackageStartupMessages(library(msa))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(gt))
suppressPackageStartupMessages(library(DECIPHER))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(openxlsx))
```

# **Sanger Analysis Report**

-   This report provides a detailed analysis of CRISPR-edited DNA sequences obtained through Sanger sequencing.

-   The analysis includes sequence base calling, quality metrics, and visualization of chromatograms and heatmaps.

-   The report is interactive, allowing easy navigation through the tables and images.

# Sequence Metrics

-   **Primary Base Call**: The main sequence predicted by the sequencing software.

-   **Internal Base Call**: A refined sequence based on raw intensity values.

```{r}
#| label: Data Import
#| include: false

batch_data <- openxlsx::read.xlsx(batch_input_file)
batch_data$number <- seq(0, nrow(batch_data) - 1)
# Create the combined sample name by concatenating the first two columns (Label and Control File)
batch_data$sample_name_combined <- paste0(batch_data$number, "-", batch_data$`Label`)
# Find the row corresponding to the current sample
sample_row <- batch_data[batch_data$sample_name_combined == sample_name, ]
# Extract the corresponding experiment file
experiment_file <- sample_row$Experiment.File
# Now, use the experiment file for input
input_file_ab1 <- file.path(input_ab1, experiment_file)

data <- read.abif(input_file_ab1)
#str(data)
#class(int)

## Convert the .ab1 files to 'sangerseqR object'
int <- sangerseq(data)

```

## Default primary base call sequence

```{r}
#| echo: false
print(int@primarySeq)
```

## Internal basecall

```{r}
#| label: Data processing 
#| echo: false

## Perform internal base calling
basecalls <- makeBaseCalls(int)
print(basecalls)
## Retrieve peak positions where a base has maximum intensity
peak_positions <- peakPosMatrix(basecalls)
#print(paste0("Sequence length after internal basecall: ", dim(peak_positions)[1]))

```

## Intensity matrix

The intensity matrix represents raw signal strengths for each DNA base (A, C, G, T) at different positions.

-   **How to interpret the table?**

    -   Each row corresponds to a nucleotide.

    -   Each column represents a position in the sequence.

    -   Higher values indicate stronger signal intensity.

```{r}
#| lable: Intensity matrix
#| echo: false

## Raw intensity values at base-called positions
intensity_matrix <- matrix(NA, nrow = 4, ncol = nrow(peak_positions))

for (base in 1:ncol(peak_positions)) { # Loop over bases
  for (position in 1:nrow(peak_positions)) { # Loop over positions
    # Get the trace position for the current base call position and base
    trace_position <- peak_positions[position, base]
    
    # If the trace position is not NA, fetch the intensity
    if (!is.na(trace_position)) {
      intensity_matrix[base, position] <- int@traceMatrix[trace_position, base]
    } else {
      # Assign 0 (or NA) for missing data
      intensity_matrix[base, position] <- 0
    }
  }
}


rownames(intensity_matrix) <- c("A", "C", "G", "T")
colnames(intensity_matrix) <- paste0("Pos", 1:nrow(peak_positions))

# Print the intensity matrix as a table
kable(intensity_matrix, format = "html", caption = "Intensity Matrix", 
      align = "c", table.attr = "class='table table-bordered table-striped table-hover'") %>%
  kable_styling("striped", full_width = FALSE) %>%
  row_spec(0, background = "#b9e7db", color = "#636A68", bold = TRUE) %>%
  column_spec(1, bold = TRUE) # Make the first column bold


intensity_df <- as.data.frame(intensity_matrix)
# Rename the first column to "Base"
colnames(intensity_df)[1] <- "Base"
# Add the row values "A", "T", "G", "C" to the first column
intensity_df$Base <- c("A", "C", "G", "T")

# Save the summary table as excel
# Define the file path
output_file <- file.path(output_path_results, "intensity_matrix.xlsx")
# Save the dataframe
write_xlsx(intensity_df, output_file)
```

```{r tblMtcarsCaption, echo=FALSE}
#| label: tbl-Mtcars-1
#| classes: dummyTable
#| tbl-cap: "Raw Intensity/Trace Matrix"
#| tbl-cap-location: top
mtcars[1,] |> knitr::kable()   # Dummy table is completely hidden from report
```

## Summary table

-   A breakdown of how many times each base (A, C, G, T) appears in the sequence.

-   The percentage composition of each base.

-   The values help check sequencing quality.

-   Unexpected high percentages of a single base may indicate sequencing errors.

```{r}
#| label: Summary Table
#| echo: false
## Overall metrics summary table
# Calculate base counts
base_count <- alphabetFrequency(int@primarySeq, baseOnly = TRUE)
# Total number of bases (excluding non-base characters like 'N')
total_bases <- sum(base_count)

summary_table <- data.frame(
  Base = names(base_count),  
  Count = as.numeric(base_count),  
  Percentage = round((as.numeric(base_count) / total_bases) * 100, 2)  
)

reactable(
  summary_table,
  defaultPageSize = nrow(summary_table),  # Show all rows without pagination
  highlight = TRUE,                      # Highlight rows on hover
  bordered = TRUE,                       # Add borders for a clean look
  striped = TRUE,                        # Add subtle row striping
  style = list(fontFamily = "Arial, sans-serif", fontSize = "16px"),  # Font customization
  columns = list(
    Base = colDef(name = "Base", align = "center"),
    Count = colDef(name = "Count", align = "center", format = colFormat(separators = TRUE)),
    Percentage = colDef(name = "Percentage (%)", align = "center")
  ),
  theme = reactableTheme(
    headerStyle = list(
      backgroundColor = "#b9e7db",  
      color = "#636A68",           # Dark text color for contrast
      fontWeight = "bold",
      fontSize = "18px",
      borderBottom = "2px solid #dddddd"  # Subtle border below the header
    )
  )
)

# Save the summary table as excel
output_file <- file.path(output_path_results, "summary_table.xlsx")
write_xlsx(summary_table, output_file)
```

```{r tblMtcarsCaption, echo=FALSE}
#| label: tbl-Mtcars-2
#| classes: dummyTable
#| tbl-cap: "Sequence Metrics Summary Table"
#| tbl-cap-location: top
mtcars[1,] |> knitr::kable()   # Dummy table is completely hidden from report
```

# Visualization

## Chromatogram

A graphical representation of the sequencing data, showing peaks for each base. Each peak corresponds to a nucleotide in the DNA sequence.

```{r}
#| label: Visualization
#| echo: false
#| fig-cap: "Chromatogram"
#| fig-cap-location: bottom

# Set the output image path
img_path <- file.path(output_path_plots, "chromatogram.png")
wdt <- length(int@primarySeq)*25
par(mar = c(0, 0, 0, 0), xpd = NA) 

# Save the chromatogram to an image file
png(img_path, width = wdt, height = 300, res = 100)  
chromatogram(int, width = length(int@primarySeq), height = 5, showcalls = "both")
dev.off()  # Close the PNG device


## Chromatogram
#chromatogram(int, width = length(int@primarySeq), height = 5, showcalls = "both")
```

```{r, results="asis", echo=FALSE}
cat(sprintf('<div style="overflow-x: auto; white-space: nowrap;">
  <img src="%s" width="%d">
  </div>', img_path, wdt))
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 1: Chromatogram
</div>
```

## Heatmap

A heatmap represents the signal intensity of each base at each position. Darker colors indicate higher intensity values.

```{r}
#| label: Heatmap
#| echo: false

# Reshape the intensity matrix for ggplot
heatmap_data <- melt(intensity_matrix, varnames = c("Base", "Position"), value.name = "Intensity")
# Log10-transform the intensity values
heatmap_data$LogIntensity <- log10(heatmap_data$Intensity + 1)  # Adding 1 to avoid log(0)

## Interactive heatmap
interactive_heatmap <- plot_ly(
  z = ~intensity_matrix, 
  x = ~colnames(intensity_matrix), 
  y = ~rownames(intensity_matrix), 
  type = "heatmap", 
  colors = c("white", "blue", "red"),  
  colorbar = list(title = "Intensity")
) %>%
  layout(
    title = "Heatmap of Base Intensities Across Positions",
    xaxis = list(
      title = "Position",
      tickvals = seq(0, length(colnames(intensity_matrix)), by = 50),  # Set tick intervals to 50
      ticktext = seq(0, length(colnames(intensity_matrix)), by = 50), # Adjust tick labels
      fixedrange = FALSE  # Allow zooming on the x-axis
    ),
    yaxis = list(
      title = "Base",
      fixedrange = TRUE  # Prevent zooming on the y-axis
    )
  )

# Display the heatmap
interactive_heatmap

# Save the interactive heatmap as HTML
output_plot <- file.path(output_path_plots, "heatmap.html")
htmlwidgets::saveWidget(interactive_heatmap, output_plot)

# Log transform intensity data for better visualization
heatmap_data$LogIntensity <- log10(heatmap_data$Intensity + 1)
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 2: Intensity Heatmap
</div>
```

## Bar plot

```{r}
#| label: Bar Plot
#| echo: false
## Stacked bar plot
ggplot_bar_plot <- ggplot(heatmap_data, aes(x = Position, y = LogIntensity, fill = Base)) +
  geom_bar(stat = "identity") +
  labs(title = "Log-transformed Base Intensities (Stacked)", x = "Position", y = "Log Intensity") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


interactive_bar_plot <- ggplotly(ggplot_bar_plot) %>%
  layout(
    title = "Log-transformed Base Intensities (Stacked)",
    xaxis = list(
      title = "Position",
      rangemode = "tozero",  # Ensure that x-axis starts from zero
      constrain = 'domain',  # Restrict zoom to the x-axis only
      fixedrange = FALSE,   # Allow zooming (on x-axis only)
      showticklabels = TRUE,
      tickmode = "linear",  # Use linear scaling for ticks
      tickangle = 45,  # Rotate tick labels for better readability
      tick0 = 0,  # Start at 0
      dtick = 50,  # Default tick interval (larger when zoomed out)
      rangeslider = list(
        visible = TRUE,  # Enable the range slider
        thickness = 0.05,  # Adjust thickness of the range slider
        bgcolor = "lightgray",  # Background color for the range slider
        bordercolor = "gray"  # Border color of the range slider
      )
    ),
    yaxis = list(
      title = "Log Intensity",
      fixedrange = TRUE  # Disable zooming on y-axis (keeps it static)
    ),
    showlegend = TRUE,
    hovermode = 'closest',  # Hover info closest to cursor
    dragmode = 'zoom'  # Enable zoom on x-axis only
  )

interactive_bar_plot 

# Save the interactive bar plot as HTML
output_plot <- file.path(output_path_plots, "Stacked_bar_plot.html")
htmlwidgets::saveWidget(interactive_bar_plot, output_plot)

```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 3: Stacked Bar Plot of Intenisty Values Vs Base Position
</div>
```

## Line plot

```{r}
#| label: Line plot
#| echo: false


interactive_line_plot <- plot_ly(
  data = heatmap_data,
  x = ~Position,
  y = ~LogIntensity,
  type = 'scatter',
  mode = 'lines+markers',
  color = ~Base,
  colors = c('red', 'green', 'blue', 'purple'),
  hoverinfo = 'x+y+text',
  text = ~paste('Base:', Base, '<br>Intensity:', LogIntensity)
) %>%
  layout(
    title = "Log-transformed Base Intensities",
    xaxis = list(
      title = "Position",
      rangemode = "tozero",  # Ensure that x-axis starts from zero
      constrain = 'domain',  # Constrain the zoom to the x-axis only
      fixedrange = FALSE,    # Allow zooming (on x-axis only)
      showticklabels = TRUE,
      rangeslider = list(
        visible = TRUE,  # Enable the range slider
        thickness = 0.05,  # Adjust the thickness of the range slider
        bgcolor = "lightgray",  # Background color of the range slider
        bordercolor = "gray",  # Border color of the range slider
        range = c(0, 50)  # Default range window size (you can adjust this)
      )
    ),
    yaxis = list(
      title = "Log Intensity",
      fixedrange = TRUE  # Disable zooming on y-axis (keeps it static)
    ),
    showlegend = TRUE,
    hovermode = 'closest',  # Hover info closest to cursor
    dragmode = 'zoom'  # Allow zooming with mouse
  )

# Display the plot
interactive_line_plot

# Save as an interactive HTML file
output_plot <- file.path(output_path_plots, "line_plot.html")
htmlwidgets::saveWidget(interactive_line_plot, output_plot)

```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 4: Line Plot of Intenisty Values Vs Base Position
</div>
```

# ICE Analysis Results

-   This section presents key analyses of CRISPR edits using ICE (Inference of CRISPR Edits).

-   It includes sequence alignments, discordance plots, indel distributions, and editing outcome tables.

## Sequence Alignments

DNA sequence alignment helps compare CRISPR-edited sequences with a reference control to identify mutations.

#### **Interpreting the Alignment**

-   The image displays the aligned sequences with color-coded nucleotides.

-   Conserved regions appear in similar colors.

-   Gaps indicate deletions, and mismatched bases are mutations.

```{r}
#| label: Alignment 
#| echo: false

setwd(output_path_results)
# Read the JSON file
json_file <- list.files(pattern = "\\.all\\.json$")
alignment_data <- fromJSON(json_file)
# Convert to DNAStringSet
control <- DNAStringSet(alignment_data$control)
edited <- DNAStringSet(alignment_data$edited)

# Combine into a single DNAStringSet object
sequences <- DNAStringSet(c(control, edited))
names(sequences) <- c("Control", "Edited")
# Align sequences
aligned_sequences <- msa(sequences)

# Convert to XStringSet for export
aligned_XStringSet <- DNAStringSet(unlist(aligned_sequences))  

writeXStringSet(aligned_XStringSet, "aligned_sequences.fasta")
# Calculate maximum sequence length
max_length <- max(width(aligned_XStringSet))

# Plot alignment
# Assuming aligned_XStringSet contains your aligned sequences
alignment <- ggmsa(aligned_XStringSet, start = 1, end = max_length, char_width = 0.5, seq_name = TRUE, color = "Chemistry_NT") +
  geom_seqlogo() + 
  theme_minimal()+ 
  theme(
    text = element_text(size = 4),   # Increases overall text size
    axis.text = element_text(size = 4),  # Increase label size
    legend.text = element_text(size = 3) # Increase legend size
  ) +
  labs(title = "Multiple Sequence Alignment")


# Set the output image path
img_path <- file.path(output_path_plots, "Alignment.png")
wdt <- max_length*25
# Save the alignment to a high-quality PNG file
ggsave(
  filename = img_path,
  plot = alignment,
  width = wdt / 350,   # Scale width properly
  height = 0.7,          # Fixed height (adjust as needed)
  units = "in",
  dpi = 300            # High resolution
)

```

```{r, results="asis", echo=FALSE}
cat(sprintf('<div style="overflow-x: auto; white-space: nowrap;">
  <img src="%s" width="%d">
  </div>', img_path, wdt))
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 5:   Sequence Alignment: Control Vs Edited
</div>
```

## Indel Distribution

## Discordance Plot

-   The discordance plot details the level of alignment per base between the wild type (control) and the edited sample in the inference window (the region around the cute site), i.e. it shows the average amount of signal that disagrees with the reference sequence derived from the control trace file.

-   On the plot, the green line and lavender line should be close together before the cut site, with a typical CRISPR edit resulting in a jump in the discordance near the cutsite and continuing to remain far apart after the cut site (representing a high level of sequence discordance).

```{r}
#| label: Discordance Plot
#| echo: false

# Load the JSON file
setwd(output_path_results)
indel_file <- list.files(pattern = "\\.indel\\.json$")
data <- fromJSON(indel_file)

# Extract relevant data from the JSON structure
bp <- data$discord_plot$bp
control_discord <- data$discord_plot$control_discord
edited_discord <- data$discord_plot$edited_discord
aln_start <- data$discord_plot$aln_start
aln_end <- data$discord_plot$aln_end
cut_site <- data$discord_plot$cut_site
inf_start <- data$discord_plot$inf_start
inf_end <- data$discord_plot$inf_end
r_sq <- data$r_sq

# Create a data frame for plotting
plot_data <- data.frame(
  Position = bp,
  Control = control_discord,
  Edited = edited_discord
)

# Convert the data to long format for ggplot2
plot_data_long <- melt(
  plot_data,
  id.vars = "Position",
  variable.name = "Sample",
  value.name = "Discordance"
)


# Plot using plotly
discordance_plotly <- plot_ly(plot_data_long, 
                              x = ~Position, 
                              y = ~Discordance, 
                              color = ~Sample, 
                              type = 'scatter', 
                              mode = 'lines',
                              line = list(width = 2),
                              hoverinfo = "text",  # This will ensure hover info appears only on hover
                              text = ~paste("Position: ", Position, "<br>Discordance: ", Discordance)  # Display hover text
) %>%
  layout(
    title = "",
    xaxis = list(
      title = "Position (bp)", 
      tickmode = "array", 
      tickvals = seq(min(plot_data_long$Position), max(plot_data_long$Position), by = 50), # Adjust x-axis ticks in steps of 50
      ticktext = seq(min(plot_data_long$Position), max(plot_data_long$Position), by = 50), # Custom ticks
      fixedrange = FALSE,
      showgrid = TRUE,  # Make grid lines visible
      zeroline = FALSE  # Hide the zero line
    ),
    yaxis = list(
      title = "Discordance", 
      fixedrange = TRUE,
      range = c(0, 1.1), # Add space above 1 to make plot visually appealing
      showgrid = TRUE,  # Make grid lines visible
      zeroline = FALSE  # Hide the zero line
    ),
    shapes = list(
      # Add shaded areas for alignment and inference windows
      list(type = "rect", x0 = aln_start, x1 = aln_end, y0 = 0, y1 = 1, fillcolor = "blue", opacity = 0.1, line = list(width = 0)),
      list(type = "rect", x0 = inf_start, x1 = inf_end, y0 = 0, y1 = 1, fillcolor = "green", opacity = 0.1, line = list(width = 0)),
      # Add vertical line for cut site
      list(type = "line", x0 = cut_site, x1 = cut_site, y0 = 0, y1 = 1, line = list(color = "#E34234", dash = "dash"))
    ),
    annotations = list(
      # Add labels for the windows and R² value
      list(x = inf_start + 28, y = 1.02, text = "Inference Window", showarrow = FALSE, font = list(size = 14, color = "#699b0e")),
      list(x = aln_start + 28, y = 1.02, text = "Alignment Window", showarrow = FALSE, font = list(size = 14, color = "#ac87cb")),
      list(x = max(plot_data_long$Position), y = 1.05, text = paste("R² = ", round(r_sq, 2)), showarrow = FALSE, font = list(size = 16, color = "gray50"))
    ),
    dragmode = "zoom",  # Allow zooming on x-axis
    xaxis = list(range = c(min(plot_data_long$Position), max(plot_data_long$Position))), # Restrict zooming to the x-axis
    yaxis = list(range = c(0, 1.1)),  # Restrict zooming to y-axis range
    showlegend = TRUE,
    legend = list(
      tracegroupgap = 0,
      itemclick = "toggleothers",  # This makes non-hovered traces transparent
      font = list(size = 12),
      orientation = 'h',  # Place the legend horizontally at the bottom
      xanchor = 'center', 
      yanchor = 'top',
      x = 0.5,
      y = -0.18
    )
  )

# Display the interactive plot
discordance_plotly
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 6:   Discordance Plot: Control Vs Edited
  Save the plot as PNG by clicking on the "camera icon" on the top right corner
</div>
```

```{r}
#| label: ICE analysis vallues
#| echo: false

print(paste0("Model Fit (R2) = ", r_sq))
print(paste0("Editing efficiency = ", ed_eff))
```

## Indel Plot

-   The Indel plot displays the inferred distribution of indels in the entire edited population of genomes.

-   Hovering over each bar of the Indel plot shows the size of the insertion or deletion (+ or - 1 or more nucleotides), along with the percentage of genomes that contain it.

-   Note: Each indel size represented in the Indel plot may not necessarily occur in the same sequence. The percentages of different indel sizes in the cell population are not the same as ICE/KO-Score scores.

```{r}
#| label: Indel Plot
#| echo: false

# Extract editing_outcomes from the data
editing_outcomes <- data$editing_outcomes

# Convert the data to a data frame
plot_data <- data.frame(
  IndelSize = as.integer(names(editing_outcomes)),
  Percentage = as.numeric(editing_outcomes)
)

# Create the bar plot using plotly without text on top of bars
indel_plot <- plot_ly(plot_data, 
                    x = ~IndelSize, 
                    y = ~Percentage, 
                    type = 'bar',
                    marker = list(color = 'rgba(55, 128, 191, 0.7)', line = list(color = 'rgba(55, 128, 191, 1)', width = 2)),
                    hoverinfo = "text",
                    text = ~paste("Indel Size: ", IndelSize, "<br>Percentage: ", Percentage, "%"),  # Keep hover info but no text on bars
                    textposition = 'none'
) %>%
  layout(
    title = "",
    xaxis = list(
      title = "Indel Size", 
      tickmode = "array", 
      tickvals = seq(min(plot_data$IndelSize), max(plot_data$IndelSize), by = 5),  # Adjust x-axis ticks in steps of 5
      ticktext = seq(min(plot_data$IndelSize), max(plot_data$IndelSize), by = 5)   # Custom ticks
    ),
    yaxis = list(
      title = "Percentage of Indels",
      range = c(0, max(plot_data$Percentage) * 1.05),  # Leave space above the max value for better aesthetics
      tickmode = "array", 
      tickvals = seq(0, max(plot_data$Percentage), by = 5),  # Adjust y-axis ticks in steps of 5
      ticktext = seq(0, max(plot_data$Percentage), by = 5)   # Custom ticks
    ),
    showlegend = FALSE  # No legend needed for this plot
  )

# Display the interactive bar plot
indel_plot
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 7:   Indel Plot
  Save the plot as PNG by clicking on the "camera icon" on the top right corner
</div>
```

## Contributions

This table summarizes the contribution of each sequence variant in the edited population.

```{r}
#| label: Editing outcome table
#| echo: false

# Step 1: Read the JSON file
setwd(output_path_results)
contribs_file <- list.files(pattern = "\\.contribs\\.json$")
json_data <- fromJSON(contribs_file)

# Step 2: Extract relevant data
contribs_list <- json_data$contribs_list

# Function to extract indel details safely
extract_indel_label <- function(indel_details) {
  if (!is.null(indel_details) && nrow(indel_details) > 0) {
    paste0(indel_details$value[1], "[", indel_details$label[1], "]")
  } else {
    "0[g1]"
  }
}

# Create dataframe
alignment_data <- data.frame(
  Sequence = contribs_list$human_readable,
  `Relative Abundance (%)` = round(contribs_list$rel_abundance * 100, 2),  # Convert to %
  `Indel Label` = sapply(contribs_list$indel$details, extract_indel_label),
  `Wild-Type` = ifelse(contribs_list$wt, "Yes", "No")
)

# Sort by relative abundance
alignment_data <- alignment_data %>%
  arrange(desc(Relative.Abundance....))

# Fix column names
colnames(alignment_data) <- c("Sequence", "Relative Abundance (%)", "Indel Label", "Wild Type")

# Rearrange columns to move 'Sequence' to the last
alignment_data <- alignment_data %>%
  select(`Indel Label`, `Relative Abundance (%)`, `Wild Type`, Sequence)

# Create a scrollable table with gt
table <- alignment_data %>%
  gt() %>%
  tab_header(title = md("**Relative contribution of each sequence (normalized)**")) %>%  # Title bold
  cols_label(
    `Indel Label` = md("**Indel Label**"),
    `Relative Abundance (%)` = md("**Relative Abundance (%)**"),
    `Wild Type` = md("**Wild Type**"),
    `Sequence` = md("**Sequence**")
  ) %>%
  cols_align(align = "center", columns = everything()) %>%  # Center align all columns
  cols_align(align = "left", columns = Sequence) %>%  # Left-align sequences
  tab_options(
    table.font.size = "small"
  ) %>%
  fmt_number(columns = `Relative Abundance (%)`, decimals = 2) %>%
  data_color(
    columns = `Wild Type`,
    colors = c("Yes" = "#C5F0FF", "No" = "#FFC5D3")
  ) %>%
  tab_style(
    style = cell_text(weight = "bold", align = "center"),
    locations = cells_column_labels(everything())  # Make column headers bold and center-aligned
  ) %>%
  tab_style(
    style = cell_text(font = "Courier New", align = "left", size = "14px"),  # Use monospace font
    locations = cells_body(columns = Sequence)
  )
table
table_df <- as.data.frame(table)
write_xlsx(table_df, "ICE_table.xlsx")
```

```{r tblMtcarsCaption, echo=FALSE}
#| label: tbl-Mtcars-3
#| classes: dummyTable
#| tbl-cap: "Relative contribution of each sequence (normalized)"
#| tbl-cap-location: top
mtcars[1,] |> knitr::kable()   # Dummy table is completely hidden from report
```

```{r}
#| label: MSA-Plot
#| echo: false
#| warning: false
#| include: false
#### Multiple Sequence Alignment ####
sequences <- alignment_data$Sequence
# Remove separator and unknown characters
sequences <- gsub("\\|", "", sequences)  # Remove separator
sequences <- gsub("n", "N", sequences)   # Convert 'n' to '-'
sequences <- gsub("-", "", sequences)    # Remove gaps for alignment


# Create a DNAStringSet
dna_set <- DNAStringSet(sequences)
names(dna_set) <- paste0(alignment_data$`Indel Label`, "_", seq_along(alignment_data$`Indel Label`))  # Name the sequences

# Perform MSA
alignment <- AlignSeqs(dna_set, anchor = NA)  # `anchor = NA` prevents fixing the reference

# Convert alignment to a data frame for visualization
alignment_fasta <- "alignment.fasta"
writeXStringSet(alignment, alignment_fasta)

max_length <- max(nchar(sequences))

msa <- ggmsa(
  alignment_fasta, start = 1, end = max_length, 
  color = "Chemistry_NT", seq_name = TRUE
) + 
  theme_minimal() +
  theme(
    text = element_text(size = 8),   # Increases overall text size
    axis.text = element_text(size = 5),  # Increase label size
    legend.text = element_text(size = 5) # Increase legend size
  ) +
  labs(title = "Multiple Sequence Alignment")

# Set the output image path
img_path <- paste0(output_path_plots, "/MSA.png")
wdt <- max_length*25
# Save the MSA to a high-quality PNG file
ggsave(
  filename = img_path,
  plot = msa,
  width = wdt / 350,   # Scale width properly
  height = 1,          # Fixed height (adjust as needed)
  units = "in",
  dpi = 300            # High resolution
)

```

```{r, results="asis", echo=FALSE}
cat(sprintf('<div style="overflow-x: auto; white-space: nowrap;">
  <img src="%s" width="%d">
  </div>', img_path, wdt))
```

```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 8: Multiple Sequence Alignment Of Different Editing Outcomes
</div>
```

```{r}
#| label: Additional plots
#| include: false
## Density plot
# ggplot(heatmap_data, aes(x = Intensity, fill = Base)) +
#   geom_density(alpha = 0.5) +
#   labs(title = "Density of Base Intensities", x = "Intensity", y = "Density") +
#   theme_minimal()
## Box plot
# ggplot(heatmap_data, aes(x = Base, y = Intensity, fill = Base)) +
#   geom_boxplot() +
#   labs(title = "Boxplot of Base Intensities", x = "Base", y = "Intensity") +
#   theme_minimal()
## Line plot
# ggplot(heatmap_data, aes(x = Position, y = Intensity, color = Base, group = Base)) +
#   geom_line() +
#   labs(title = "Base Intensities Across Positions", x = "Position", y = "Intensity") +
#   theme_minimal()
## Heatmap
# ggplot(heatmap_data, aes(x = Position, y = Base, fill = Intensity)) +
#   geom_tile() +
#   scale_fill_gradient(low = "white", high = "red") +
#   labs(title = "Base Intensities Across Positions", x = "Position", y = "Base") +
#   theme_minimal()
```

# Session Info

```{r, echo=FALSE}
sessionInfo()
```
