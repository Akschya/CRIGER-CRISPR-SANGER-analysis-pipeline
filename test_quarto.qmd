---
title: "SANGER ANALYSIS REPORT"
subtitle: "Complete analysis report on CRSIPR edited reads after Sanger sequencing, using ICE and R statistical analysis."
date: now
format: 
  html: 
    title-block-banner: true
    title-block-style: default
    toc: true
    toc-depth: 2
    toc-title: "Contents"
    toc-location: left
    theme:
      light: minty
      dark: darkly
    embed-resources: true
    df-print: kable
    code-links: 
    - text: CRISPR Analysis Repo
      icon: github
      href: https://github.com/Akschya/CRISPR_Analysis 
editor: visual
---

```{r, include=FALSE}
### Env variable setup ###
# Set environment variables dynamically in the R chunk
output_dir <- Sys.getenv("OUTPUT_DIR")
input_ab1 <- Sys.getenv("INPUT_AB1")
analysis_type <- Sys.getenv("ANALYSIS_TYPE")
batch_file <- Sys.getenv("BATCH_INPUT_FILE")
```

```{css classDummyTable, echo=FALSE}
.dummyTable .table thead {
    visibility: collapse;
}
.dummyTable .table tbody {
    visibility: collapse;
}
.dummyTable .table {
    border-collapse: inherit;
    padding-bottom: none;
}
.dummyTable .table.table.table-sm.table-striped.small {
    margin: auto;
}
```

```{r setup, include=FALSE}
#| label: R environment setup

#### R ENV SETUP ####
options(repos = c(
  binary = "https://packagemanager.rstudio.com/all/__linux__/focal/latest",
  source = "https://packagemanager.rstudio.com/all/latest",
  CRAN = "https://cloud.r-project.org",
  djnavarro = "https://djnavarro.r-universe.dev",
  Bioconductor = "https://bioconductor.org/packages/release/bioc"
))

# Load the yaml package to read YAML files
if (!require(yaml)) {
  install.packages("yaml")
  library(yaml)
}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
    library(BiocManager)

# Define function to install packages from 'packages.yml'
install_packages <- function(file = "packages.yml") {
  # Read the YAML file
  packages <- yaml::read_yaml(file)
  
  # Get the list of available Bioconductor packages
  bioc_pkgs <- BiocManager::available()
  
  # Loop through each package and install it
  for (pkg in packages) {
    if (any(pkg %in% bioc_pkgs)) {
      BiocManager::install(pkg, ask = FALSE)  # Install Bioconductor package
    } else {
      install.packages(pkg)  # Install CRAN or other packages
    }
  }
}

# Install packages from the 'packages.yml' file
install_packages()
```

# Sequence Metrics

```{r setup, include=FALSE}
# Load necessary libraries
library(sangerseqR)
library(pheatmap)
library(ggplot2)
library(reshape2)
library(plotly)
library(Biostrings)
library(kableExtra)
library(DT)
library(reactable)
library(writexl)

```

```{r, include=FALSE}

#| label: Data Import

data <- read.abif(input_file)
#str(data)
#class(int)

## Convert the .ab1 files to 'sangerseqR object'
int <- sangerseq(data)

```

## Default primary base call sequence

```{r, echo=FALSE}
print(int@primarySeq)
```

## Internal basecall

```{r, echo=FALSE}
#| label: Data processing 

## Perform internal base calling
basecalls <- makeBaseCalls(int)
print(basecalls)
## Retrieve peak positions where a base has maximum intensity
peak_positions <- peakPosMatrix(basecalls)
#print(paste0("Sequence length after internal basecall: ", dim(peak_positions)[1]))

```

## Intensity matrix

```{r, echo=FALSE}
#| lable: Intensity matrix

## Raw intensity values at base-called positions
intensity_matrix <- matrix(NA, nrow = 4, ncol = nrow(peak_positions))

for (base in 1:ncol(peak_positions)) { # Loop over bases
  for (position in 1:nrow(peak_positions)) { # Loop over positions
    # Get the trace position for the current base call position and base
    trace_position <- peak_positions[position, base]
    
    # If the trace position is not NA, fetch the intensity
    if (!is.na(trace_position)) {
      intensity_matrix[base, position] <- int@traceMatrix[trace_position, base]
    } else {
      # Assign 0 (or NA) for missing data
      intensity_matrix[base, position] <- 0
    }
  }
}


rownames(intensity_matrix) <- c("A", "C", "G", "T")
colnames(intensity_matrix) <- paste0("Pos", 1:nrow(peak_positions))

# Print the intensity matrix as a table
kable(intensity_matrix, format = "html", caption = "Intensity Matrix", 
      align = "c", table.attr = "class='table table-bordered table-striped table-hover'") %>%
  kable_styling("striped", full_width = FALSE) %>%
  row_spec(0, background = "#b9e7db", color = "#636A68", bold = TRUE) %>%
  column_spec(1, bold = TRUE) # Make the first column bold


intensity_df <- as.data.frame(intensity_matrix)
# Rename the first column to "Base"
colnames(intensity_df)[1] <- "Base"
# Add the row values "A", "T", "G", "C" to the first column
intensity_df$Base <- c("A", "C", "G", "T")
# Save the summary table as excel
write_xlsx(intensity_df, "intensity_matrix.xlsx")

```

```{r tblMtcarsCaption, echo=FALSE}
#| label: tbl-Mtcars-1
#| classes: dummyTable
#| tbl-cap: "Intensity Matrix"
#| tbl-cap-location: top
mtcars[1,] |> knitr::kable()   # Dummy table is completely hidden from report
```

## Summary table

```{r, echo=FALSE}
## Overall metrics summary table
# Calculate base counts
base_count <- alphabetFrequency(int@primarySeq, baseOnly = TRUE)
# Total number of bases (excluding non-base characters like 'N')
total_bases <- sum(base_count)

summary_table <- data.frame(
  Base = names(base_count),  
  Count = as.numeric(base_count),  
  Percentage = round((as.numeric(base_count) / total_bases) * 100, 2)  
)

reactable(
  summary_table,
  defaultPageSize = nrow(summary_table),  # Show all rows without pagination
  highlight = TRUE,                      # Highlight rows on hover
  bordered = TRUE,                       # Add borders for a clean look
  striped = TRUE,                        # Add subtle row striping
  style = list(fontFamily = "Arial, sans-serif", fontSize = "16px"),  # Font customization
  columns = list(
    Base = colDef(name = "Base", align = "center"),
    Count = colDef(name = "Count", align = "center", format = colFormat(separators = TRUE)),
    Percentage = colDef(name = "Percentage (%)", align = "center")
  ),
  theme = reactableTheme(
    headerStyle = list(
      backgroundColor = "#b9e7db",  
      color = "#636A68",           # Dark text color for contrast
      fontWeight = "bold",
      fontSize = "18px",
      borderBottom = "2px solid #dddddd"  # Subtle border below the header
    )
  )
)

# Save the summary table as excel
write_xlsx(summary_table, "summary_table.xlsx")
```
```{r tblMtcarsCaption, echo=FALSE}
#| label: tbl-Mtcars-2
#| classes: dummyTable
#| tbl-cap: "Sequence Metrics Summary"
#| tbl-cap-location: top
mtcars[1,] |> knitr::kable()   # Dummy table is completely hidden from report
```

# Visualization

## Chromatogram

```{r, echo=FALSE}
#| label: Visualization
#| fig-cap: "Chromatogram"
#| fig-cap-location: bottom

# Set the output image path
img_path <- "chromatogram.png"
wdt <- length(int@primarySeq)*25
par(mar = c(0, 0, 0, 0), xpd = NA) 

# Save the chromatogram to an image file
png(img_path, width = wdt, height = 300, res = 100)  
chromatogram(int, width = length(int@primarySeq), height = 5, showcalls = "both")
dev.off()  # Close the PNG device


## Chromatogram
#chromatogram(int, width = length(int@primarySeq), height = 5, showcalls = "both")
```

```{=html}
<div style="overflow-x: auto; white-space: nowrap;">
  <img src="chromatogram.png" width="{{ wdt }}">
</div>
```
```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 1: Chromatogram
</div>
```
## Heatmap

```{r, echo=FALSE}


# Reshape the intensity matrix for ggplot
heatmap_data <- melt(intensity_matrix, varnames = c("Base", "Position"), value.name = "Intensity")
# Log10-transform the intensity values
heatmap_data$LogIntensity <- log10(heatmap_data$Intensity + 1)  # Adding 1 to avoid log(0)

## Interactive heatmap
interactive_heatmap <- plot_ly(z = ~intensity_matrix, x = ~colnames(intensity_matrix), y = ~rownames(intensity_matrix), 
        type = "heatmap", colors = c("white", "blue", "red"),  colorbar = list(title = "Intensity")) %>%
  layout(
    title = "Heatmap of Base Intensities Across Positions",
    xaxis = list(
      title = "Position",
      tickvals = seq(0, length(colnames(intensity_matrix)), by = 50),  # Set tick intervals to 50
      ticktext = seq(0, length(colnames(intensity_matrix)), by = 50)   # Adjust tick labels accordingly
    ),  
    yaxis = list(title = "Base")
  )

interactive_heatmap


# Save the interactive bar plot as HTML
htmlwidgets::saveWidget(interactive_heatmap, "interactive_heatmap.html")

# Log transform intensity data for better visualization
heatmap_data$LogIntensity <- log10(heatmap_data$Intensity + 1)
```
```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 2: Intensity heatmap
</div>
```

## Bar plot

```{r, echo=FALSE}

## Stacked bar plot
ggplot_bar_plot <- ggplot(heatmap_data, aes(x = Position, y = LogIntensity, fill = Base)) +
  geom_bar(stat = "identity") +
  labs(title = "Log-transformed Base Intensities (Stacked)", x = "Position", y = "Log Intensity") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


interactive_bar_plot <- ggplotly(ggplot_bar_plot) %>%
  layout(
    title = "Log-transformed Base Intensities (Stacked)",
    xaxis = list(
      title = "Position",
      rangemode = "tozero",  # Ensure that x-axis starts from zero
      constrain = 'domain',  # Restrict zoom to the x-axis only
      fixedrange = FALSE,   # Allow zooming (on x-axis only)
      showticklabels = TRUE,
      tickmode = "linear",  # Use linear scaling for ticks
      tickangle = 45,  # Rotate tick labels for better readability
      tick0 = 0,  # Start at 0
      dtick = 50,  # Default tick interval (larger when zoomed out)
      rangeslider = list(
        visible = TRUE,  # Enable the range slider
        thickness = 0.05,  # Adjust thickness of the range slider
        bgcolor = "lightgray",  # Background color for the range slider
        bordercolor = "gray"  # Border color of the range slider
      )
    ),
    yaxis = list(
      title = "Log Intensity",
      fixedrange = TRUE  # Disable zooming on y-axis (keeps it static)
    ),
    showlegend = TRUE,
    hovermode = 'closest',  # Hover info closest to cursor
    dragmode = 'zoom'  # Enable zoom on x-axis only
  )

interactive_bar_plot 

# Save the interactive bar plot as HTML
htmlwidgets::saveWidget(interactive_bar_plot, "interactive_bar_plot.html")

```
```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 3: Stacked bar plot
</div>
```

## Line plot

```{r, echo=FALSE}
## Line plot
interactive_line_plot <- plot_ly(
  data = heatmap_data,
  x = ~Position,
  y = ~LogIntensity,
  type = 'scatter',
  mode = 'lines+markers',
  color = ~Base,
  colors = c('red', 'green', 'blue', 'purple'),
  hoverinfo = 'x+y+text',
  text = ~paste('Base:', Base, '<br>Intensity:', LogIntensity)
) %>%
  layout(
    title = "Log-transformed Base Intensities",
    xaxis = list(
      title = "Position",
      rangemode = "tozero",  # Ensure that x-axis starts from zero
      constrain = 'domain',  # Constrain the zoom to the x-axis only
      fixedrange = FALSE,    # Allow zooming (on x-axis only)
      showticklabels = TRUE,
      rangeslider = list(
        visible = TRUE,  # Enable the range slider
        thickness = 0.05,  # Adjust the thickness of the range slider
        bgcolor = "lightgray",  # Background color of the range slider
        bordercolor = "gray",  # Border color of the range slider
        range = c(0, 50)  # Default range window size (you can adjust this)
      )
    ),
    yaxis = list(
      title = "Log Intensity",
      fixedrange = TRUE  # Disable zooming on y-axis (keeps it static)
    ),
    showlegend = TRUE,
    hovermode = 'closest',  # Hover info closest to cursor
    dragmode = 'zoom'  # Allow zooming with mouse
  )

# Display the plot
interactive_line_plot

# Save as an interactive HTML file
htmlwidgets::saveWidget(interactive_line_plot, "interactive_line_plot.html")

```
```{=html}
<div style="text-align: center; color: gray; font-size: 0.9em;">
  Figure 4: Line Plot
</div>
```


```{r, include=FALSE}
#| label: Additional plots
## Density plot
# ggplot(heatmap_data, aes(x = Intensity, fill = Base)) +
#   geom_density(alpha = 0.5) +
#   labs(title = "Density of Base Intensities", x = "Intensity", y = "Density") +
#   theme_minimal()
## Box plot
# ggplot(heatmap_data, aes(x = Base, y = Intensity, fill = Base)) +
#   geom_boxplot() +
#   labs(title = "Boxplot of Base Intensities", x = "Base", y = "Intensity") +
#   theme_minimal()
## Line plot
# ggplot(heatmap_data, aes(x = Position, y = Intensity, color = Base, group = Base)) +
#   geom_line() +
#   labs(title = "Base Intensities Across Positions", x = "Position", y = "Intensity") +
#   theme_minimal()
## Heatmap
# ggplot(heatmap_data, aes(x = Position, y = Base, fill = Intensity)) +
#   geom_tile() +
#   scale_fill_gradient(low = "white", high = "red") +
#   labs(title = "Base Intensities Across Positions", x = "Position", y = "Base") +
#   theme_minimal()
```
# Session Info

```{r, echo=FALSE}
sessionInfo()
```
